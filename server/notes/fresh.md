# islands

islands 是最近比较流行的一个词。在前端翻译为孤岛。

`孤岛架构`是最近比较流行的一种架构。指的是在 html 中, 组件就像是一个一个小岛一样。部分组件是独立与其他组件的。这些组件就像是独立的岛屿。最早是在 [Islands Architecture](https://jasonformat.com/islands-architecture/) 这篇文章中提出的。

早期使用类似方案的其实也有，比如 facebook 的 [bigpipe](https://engineering.fb.com/2010/06/04/web/bigpipe-pipelining-web-pages-for-high-performance/)。以及 [Async Fragments: Rediscovering Progressive HTML Rendering with Marko](https://tech.ebayinc.com/engineering/async-fragments-rediscovering-progressive-html-rendering-with-marko/)。最近比较流行的是 [fresh](https://fresh.deno.dev/)。

本篇文章主要分析 fresh 的代码，探讨 fresh 是如何实现 islands 架构的。

先看 fresh 的 example 的结构

```text
.
├── README.md
├── deno.json
├── dev.ts
├── fresh.gen.ts
├── import_map.json
├── islands
│   └── Counter.tsx
├── main.ts
└── routes
    └── index.tsx
```

存在两个主要文件夹 `islands` 和 `routes`。`routes` 文件顾名思义就是路由的意思，可以在此文件夹下定义相关的路由。`islands` 文件夹是用来放一些组件，这些组件可以一个个岛屿，渲染的时候可以对这些组件进行部分注水。从而实现 `islands` 架构。

再看看 `fresh.gen.ts` 文件，在这个文件对组件进行了分类，主要有 `routes` 和 `islands`。

```ts
// DO NOT EDIT. This file is generated by fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running `dev.ts`.

import * as $0 from './routes/index.tsx'
import * as $$0 from './islands/Counter.tsx'

const manifest = {
  routes: {
    './routes/index.tsx': $0
  },
  islands: {
    './islands/Counter.tsx': $$0
  },
  baseUrl: import.meta.url
}

export default manifest
```

`routes` 和 `islands` 的 key 都为文件路径，值为导出的所有。这个文件是自动生成的。这里为什么是导出所有，是因为也可以在内部定义其他变量导出从而传递到框架中。

服务端渲染主要分为两部分 1. 服务端脱水成 html 发送到浏览器中。 2. 客户端注水比如增加一些事件等等只有客户端才能做的事情。

我们也从这两部分触发，看看 fresh 是如何做的。在 fresh 内部主要关注两个文件即可，`runtime/main.ts` 和 `server/render.tsx`。其他的文件主要是一个辅助文件，比如 `context.ts` 是用来生成上下文，从而贯穿整个 server 的生命周期。此文件中包括了如何处理 `manifest`、文件读取、中间件操作等等。感兴趣的可以全部都看一遍。

先看 `render.tsx` 文件，其中有几个关键部分。

```ts
if (ENCOUNTERED_ISLANDS.size > 0) {
  // Load the main.js script
  {
    const randomNonce = crypto.randomUUID().replace(/-/g, '')
    if (csp) {
      csp.directives.scriptSrc = [
        ...(csp.directives.scriptSrc ?? []),
        nonce(randomNonce)
      ]
    }
    const url = bundleAssetUrl('/main.js')
    imports.push([url, randomNonce] as const)
  }

  script += `import { revive } from "${bundleAssetUrl('/main.js')}";`

  // Prepare the inline script that loads and revives the islands
  let islandRegistry = ''
  for (const island of ENCOUNTERED_ISLANDS) {
    const randomNonce = crypto.randomUUID().replace(/-/g, '')
    if (csp) {
      csp.directives.scriptSrc = [
        ...(csp.directives.scriptSrc ?? []),
        nonce(randomNonce)
      ]
    }
    const url = bundleAssetUrl(`/island-${island.id}.js`)
    imports.push([url, randomNonce] as const)
    script += `import ${island.name} from "${url}";`
    islandRegistry += `${island.id}:${island.name},`
  }
  script += `revive({${islandRegistry}}, STATE[0]);`
}


...etc

bodyHtml +=
      `<script type="module" nonce="${randomNonce}">${script}</script>`;
```

这部分代码通过内联脚本的形式，加载 main.js 以及每个 `islands` 组件的 js。并且到 main.js 中导入 `revive` 方法，将组装好的 `islands` 对象传递给 `revive`。再看看 `revive` 是如何实现的。

```ts
import { ComponentType, h, options, render } from 'preact'

export function revive(islands: Record<string, ComponentType>, props: any[]) {
  function walk(node: Node | null) {
    const tag =
      node!.nodeType === 8 &&
      ((node as Comment).data.match(/^\s*frsh-(.*)\s*$/) || [])[1]
    let endNode: Node | null = null
    if (tag) {
      const startNode = node!
      const children = []
      const parent = node!.parentNode
      // collect all children of the island
      while ((node = node!.nextSibling) && node.nodeType !== 8) {
        children.push(node)
      }
      startNode.parentNode!.removeChild(startNode) // remove start tag node

      const [id, n] = tag.split(':')
      render(
        h(islands[id], props[Number(n)]),
        createRootFragment(
          parent! as HTMLElement,
          children
          // deno-lint-ignore no-explicit-any
        ) as any as HTMLElement
      )
      endNode = node
    }

    const sib = node!.nextSibling
    const fc = node!.firstChild
    if (endNode) {
      endNode.parentNode?.removeChild(endNode) // remove end tag node
    }

    if (sib) walk(sib)
    if (fc) walk(fc)
  }
  walk(document.body)
}
```

在 `revive` 方法中会判断当前是否是标记的 fresh islands 组件。如果是则调用 preact 的 render 方法。

整个过程还是很简单的，如果是 islands 组件，则进行标记，在客户端渲染的时候只针对标记的组件调用 `render` 方法，其他的不调用 `render` 方法。从整个过程来说，目前孤岛架构的方式比较适合用交互较少的网站。比如 blog 网站，因为它只会对 islands 组件进行注水，其他的部分不注水。如果是交互较多的网站，这对用户的心智负担就会比较重。用户需要来判断当前组件是否为 `islands` 组件。有可能当前需求下是 islands 组件，下一个需求就不是 islands 组件了。
